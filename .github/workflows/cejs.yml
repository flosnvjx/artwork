name: cejs
on:
  workflow_dispatch:
    inputs:
      ids:
        required: true
      scheme:
        type: choice
        required: true
        options:
          - u17
        default: u17
      storage:
        type: choice
        required: true
        options:
          - cloud189
          - release
        default: release
      annot:
run-name: ${{ inputs.scheme }}/${{ inputs.annot }}
defaults:
  run:
    shell: bash
env:
  resIds: ${{ inputs.ids }}
  resScheme: ${{ inputs.scheme }}
  resStor: ${{ inputs.storage }}
  resAnnot: ${{ inputs.annot }}
  cejsVer: latest
  cejsEpoch: 1
  requireCreateTag: 0
jobs:
  in-one-go:
    runs-on: ubuntu-latest
    steps:
      - name: cache.npm(cejs_c)
        uses: actions/cache@v3
        with:
          path: cejs_c
          key: node_modules-cejs_c-${{ env.cejsVer }}_${{ env.cejsEpoch }}
      - name: main()
        run: |
          if ! [[ -d cejs_c ]]; then
            git clone -qb flos --depth 1 --single-branch https://github.com/flosnvjx/work_crawler.git/ cejs_c
            env -C cejs_c -- npm install --silent cejs
          fi

          mkdir -p "$resScheme/(upqueue)"

          declare +x -a resIdsArr=($(printf '%s' "$resIds" | sed -sEe 's%[,; ]+%\n%g' | grep -Ee '^[0-9]+$'))
          declare +x -a okIdsArr=() errIdsArr=()

          for walkId in "${resIdsArr[@]}"; do
            sleep 1.$RANDOM
            if NODE_TLS_REJECT_UNAUTHORIZED=0 node cejs_c/comic.*/"$resScheme".js "$walkId" archive_images=false
            then
              okIdsArr+=("$walkId")
            else
              errIdsArr+=("$walkId")
            fi
          done

          cd "$resScheme"
          set -f; declare +x walkWorkDir walkWorkId
          IFS=$'\n'
          for walkWorkDir in $(find . -maxdepth 1 -type d -regex './[1-9][0-9]* .*'); do
            walkWorkId="$(basename -- "$walkWorkDir" | sed -zEe 's%^([0-9]+) .*%\1%')"
            if find "$walkWorkDir" -type f -print0 | sed -zEe 's%\./%%' | LC_ALL=C sort -zt/ | cpio -o0cC1 -R +0:+0 --reproducible --quiet | tee -- "(upqueue)/$walkWorkId.cpio-ing" >&-; then
              mv -T -- "(upqueue)/$walkWorkId."cpio{-ing,}
              rm -rf -- "$walkWorkDir"
            fi
          done

          cd '(upqueue)'
          find -maxdepth 1 -type f -name '*.cpio' -print0 | \
          time xargs -0r zstdmt -q --ultra -14 --rm --

          resAnnot="$(printf %s "$resAnnot" | sed -ze 's%[\n]% %g' | sed -Ee 's|[/. ~^?*]|-|g;s|@|()|g;s%\[%(%g;s%\]%)%g' | sed -Ee 's%^-+%%')"
          if [[ -z "$resAnnot" ]]; then
            resAnnot="$(TZ=Asia/Shanghai date +%Y%m%d%H%M%S)"
          fi
          echo resAnnot=$resAnnot >> $GITHUB_ENV
          if [[ "$resStor" == release ]]; then
            if ! curl -qgsfo /dev/null "https://github.com/$GITHUB_REPOSITORY/releases/tags/$resScheme/$resAnnot"; then
              echo requireCreateTag=1 >> $GITHUB_ENV
            fi
          fi
          if [[ "$resStor" == release ]]; then
            7za a -tzip -mx=0 -bsp0 -bso0 -sae -sdel -- "$resAnnot.dataset.zz" '*.cpio.zst'
          fi
          if [[ ${#okIdsArr[@]} -gt 0 ]]; then
            printf '%s\n' "${okIdsArr[@]}" | zstd -qo "$resAnnot".cejs-ok.log.zst
          fi
          if [[ ${#errIdsArr[@]} -gt 0 ]]; then
            printf '%s\n' "${errIdsArr[@]}" | zstd -qo "$resAnnot".cejs-err.log.zst
          fi
      - name: cache.go(cloud189)
        if: inputs.storage == 'cloud189'
        uses: actions/cache@v3
        with:
          path: ~/go/bin/cloud1*
          key: go-bin-cloud189
      - name: go(cloud189)
        if: inputs.storage == 'cloud189'
        run: |
          if ! [[ -x ~/go/bin/cloud189 ]]; then
            go install github.com/gowsp/cloud189/cmd/cloud189@latest
          fi
      - name: cloud189()
        if: inputs.storage == 'cloud189'
        env:
          CLOUD189_CONFIGTEXT: ${{ secrets.CLOUD189_CONFIGTEXT }}
        run: |
          declare +x f=

          mkdir -p ~/.config/cloud189
          printf %s "$CLOUD189_CONFIGTEXT" | jq -cr . | tee > ~/.config/cloud189/config.json

          cloud189() {
            ~/go/bin/cloud189 "${@}"
          }

          upload189() {
            if [[ $# -gt 1 ]]; then
              local +x remote="$1"
              shift
            else
              local +x remote="/apps/artwork/$resScheme"
            fi
            while [[ $# -gt 0 ]]; do
              local fsz="$(stat -c "%s" -- "$1")"
              if cloud189 up "$1" "$remote" | tail -1 | tee /dev/stderr | grep -qe 'upload complete'; then
                printf '%s\n' "cloud189($1): $fsz"
              else
                printf '%s\n' "cloud189($1): $fsz FAILURE"
                return 1
              fi
              shift
            done
          }

          cd "$resScheme/(upqueue)"
          upload189 "/apps/artwork/$resScheme" "$resAnnot.cejs-"*.log.zst || exit
          declare +x f=
          if find . -name "*.cpio.zst" &>/dev/null; then
            for f in *.cpio.zst; do
              upload189 "$f" || break
              rm -- "$f"
            done
          fi
      - name: release(${{ inputs.scheme }}/${{ env.resAnnot }})
        if: inputs.storage == 'release'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          find "$resScheme/(upqueue)" -name "$resAnnot.cejs-*.log.zst" \
                                   -o -name "$resAnnot.dataset.zz" -print0 | \
          {
            if [[ "$requireCreateTag" == 1 ]]; then
              gh release create "$resScheme/$resAnnot" -p --target 63da79a3e51fc466a4a9f5629c8f125bb87bc653 -R "$GITHUB_REPOSITORY" <&-
              requireCreateTag=0
            fi
            xargs -0rI@@ gh release upload "$resScheme/$resAnnot" @@ -R "$GITHUB_REPOSITORY"
          }
